package inheritanceoverriding

language A {
	syntax "platform:/plugin/fr.inria.diverse.melange.examples.metamodels.fsm/model/FSM.ecore"
	with inheritanceoverriding.A1
	exactType AMT
}

language B inherits A {
	with inheritanceoverriding.C1
	with inheritanceoverriding.B2
	with inheritanceoverriding.OverrideA1
	exactType BMT
}

language C inherits B {
	with inheritanceoverriding.B1
	with inheritanceoverriding.B2
	with inheritanceoverriding.OverrideC1
	exactType CMT
}

language D inherits C {
	with inheritanceoverriding.C2
	with inheritanceoverriding.OverrideB2
	exactType DMT
}

language X inherits A {
	with inheritanceoverriding.C1
	with inheritanceoverriding.B1
	with inheritanceoverriding.B1
	exactType XMT
}

language Y inherits A, X {
	with inheritanceoverriding.B2
	with inheritanceoverriding.B2
	exactType YMT
}

language Z inherits A {
	exactType ZMT
}

//transformation visitA(AMT m) {
//	val root = m.contents.head as inheritanceoverriding.amt.FSM
//
//	print("f1 = ")
//	root.f1
//	root.ownedState.forEach[s |
//		println("Visiting state("+s.name+")")
//		s.outgoingTransition.forEach[t |
//			println("\tVisiting trans("+t.input+")")
//		]
//	]
//	println
//}
//
//@Main
//transformation main() {
//	val mA = A.load("input/SimpleA.xmi")
//	val mB = B.load("input/SimpleB.xmi")
//	val mC = C.load("input/SimpleC.xmi")
//	val mD = D.load("input/SimpleD.xmi")
//	val mX = X.load("input/SimpleX.xmi")
//	val mY = Y.load("input/SimpleY.xmi")
//	val mZ = Z.load("input/SimpleZ.xmi")
//
//	visitA.call(mA)
//	visitA.call(mB)
//	visitA.call(mC)
//	visitA.call(mD)
//	visitA.call(mX)
//	visitA.call(mY)
//	visitA.call(mZ)
//}
