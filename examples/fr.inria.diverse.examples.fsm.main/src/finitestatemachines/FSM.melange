package finitestatemachines

//modeltype IStateMachine{
//	ecore "platform:/resource/fr.inria.diverse.examples.fsm.interfaces/models/ifsm.ecore"
//}

// Implementation 1: State machines that comply to the Run-To-Completion policy: UML and Rhapsody.
metamodel FiniteStateMachineRTC /**implements IStateMachine*/ {
	ecore "platform:/resource/fr.inria.diverse.examples.fsm.metamodel/models/fsm.ecore"
	exactType FiniteStateMachineRTCMT

	with finitestatemachines.rtc.StateMachineAspect
	with finitestatemachines.rtc.StateAspect
} 

//// Implementation 2: State machines that accept simultaneous events: Classical statecharts.
metamodel FiniteStateMachineSimultaneous{
	ecore "platform:/resource/fr.inria.diverse.examples.fsm.metamodel/models/fsm.ecore"
	exactType FiniteStateMachineSimultaneousMT
	
	with finitestatemachines.simultaneous.StateMachineAspect
	with finitestatemachines.simultaneous.StateAspect
}

transformation execute(FiniteStateMachineRTCMT stateMachine, String input, String outputFile){
	val root = stateMachine.contents.head as finitestatemachines.finitestatemachinertcmt.StateMachine
	root.eval(new FSM.interfaces.Context(input), outputFile)
}

// Execution of the state machines.
@Main
transformation main(){
	val simpleProgram = FiniteStateMachineRTC.load("input/dummie.xmi")
	execute.call(simpleProgram, "{x;y;z,o;p;q}", "output/dummie-output " + 
		System.currentTimeMillis + ".pdf")

	val simpleProgram2 = FiniteStateMachineSimultaneous.load("input/dummie.xmi")
	execute.call(simpleProgram2, "{x;y;z,o;p;q}", "output/dummie-output " + 
		System.currentTimeMillis + ".pdf")
}
